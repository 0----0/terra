<!-- from: https://gist.github.com/2554919 -->
<style type="text/css">

body {
  font-family: Georgia, serif;
  font-size: 16px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px;
}

#allstuff {
  width: 600px;
  margin-left: 10%;
}
body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  font-family: Helvetica, serif;
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 20px;
  font-weight: normal;
  font-family: Georgia;
  letter-spacing:2px;
  font-variant: small-caps;
  text-transform: lowercase;
  color: black; }

h3 {
  font-size: 16px;
  font-family: Georgia;
  font-style:italic;
  font-weight: normal; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0; }

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }

ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

ul :last-child, ol :last-child {
  margin-bottom: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  font-size: 14px;
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }
</style>
<body>
<div id="allstuff">
<p><h1>Getting Started with Terra</h1>

<p><em>Zach DeVito <a href="&#x6D;&#97;i&#x6C;&#116;&#111;:z&#100;&#x65;&#x76;&#x69;&#x74;&#x6F;&#64;&#x73;&#x74;&#97;&#110;f&#111;&#114;&#100;&#46;e&#100;&#x75;">z&#100;&#x65;&#x76;&#x69;&#x74;&#x6F;&#64;&#x73;&#x74;&#97;&#110;f&#111;&#114;&#100;&#46;e&#100;&#x75;</a></em></p>

<p>Terra is a new low-level system programming language that is designed to interoperate seamlessly with the Lua programming language, while still being backwards compatible with (and embeddable in) existing C code. Like C, Terra is a monomorphic, statically-typed, compiled language with manual memory management. But unlike C, it is designed to make interaction with Lua easy. Terra code shares Lua's syntax and control-flow constructs. It is easy to call Lua functions from Terra (or Terra functions from Lua). </p>

<p>Additionally, Lua serves as the meta-programming language for Terra code.  Lua handles details of Terra code like conditional compilation, namespaces, and templating that are normally special constructs in low-level languages.  Furthermore, this coupling enables more powerful features like function specialization, lisp-style macros, and manually controlled JIT compilation. Since Terra's compiler is available at runtime, it makes it easy to write libraries or embedded languages that need to generate low-level code dynamically.</p>

<p>This guide serves as an introduction for programming in Terra. A general understanding of the Lua language would be very helpful, but not strictly required.</p>

<h2>Rationale</h2>

<p>Programming languages make fundamental tradeoffs between productivity and performance.  While JIT compilers can make dynamic languages like Python, Javascript, or Lua run more efficiently, they rarely match the performance of a low-level language like C, and can be difficult to use in a embedded/power-constrained context. On the flip side, C is much more difficult and error-prone to program in.</p>

<p>Other languages like Go, C++, D, Scala, Java, or, Cython try to strike a balance beween these constraints. But this can increase the total complexity of the language, and can create weird interactions between features.</p>

<p>An alternative popular in the game programming community is to use two programming languages. A performance language (typically C/C++) for rendering and simulation, and a dynamic language (often Lua) for scripting and configuration.  </p>

<p>Though Lua was designed from first principles to work with C, C was not designed to interoperate easily with dynamic languages.  Terra is fills this gap by being a low-level language designed to work with Lua. In contrast to Lua, Terra is statically typed, monomorphic, and manually manages memory.  However, unlike C, Terra is specifically designed to make interaction with Lua seamless.  The result is a pair of languages that are individually simple, but combine in powerful ways.</p>

<h2>Installation</h2>

<p>This section will walk you through installing Terra's dependencies, and building the library. Terra is being developed on Mac OS X. It should also run on Linux, but it has not been tested on Linux yet, so there are probably small problems like missing headers, and different locations for some libraries.</p>

<p>Terra uses LLVM 3.1, Clang 3.1 (the C/C++ frontend for LLVM), and LuaJIT 2.0 -- a tracing-JIT for Lua code.  Terra will download and compile LuaJIT for you, but you will need to install Clang and LLVM. The easiest way to do this is to the download the <em>Clang Binaries</em> (which also include LLVM binaries) from
<a href="http://llvm.org/releases/download.html">LLVM download</a> page.</p>

<p>Unzip the tar ball and then copy it into <code>/usr/local</code>:</p>

<pre><code>$ tar -xf clang+llvm-3.1-x86_64-apple-darwin11.tar.gz
$ cp -r clang+llvm-3.1-x86_64-apple-darwin11/ /usr/local
</code></pre>

<p>Clang should now report being version 3.1:</p>

<pre><code>$ clang --version
clang version 3.1 (branches/release_31)
Target: x86_64-apple-darwin10.8.0
Thread model: posix
</code></pre>

<p>Type make in the <code>terra</code> directory to build Terra:</p>

<pre><code>$ make
</code></pre>

<h2>Running Terra</h2>

<p>Similar to the design of Lua, Terra can be used as a standalone interpreter/read-eval-print-loop (REPL) and also as a library embedded in a C program. <code>libterra.a</code>. This design makes it easy to integrate with existing projects.</p>

<p>To run the REPL:</p>

<pre><code>$ ./terra

Terra -- A low-level counterpart to Lua

Stanford University
zdevito@stanford.edu

&gt;
</code></pre>

<p>Terra's REPL behaves similar to Lua's REPL. If you are familiar with other languages like Python, the one major difference is that expressions must be prefixed with <code>return</code> or <code>=</code> if you want to get their value:</p>

<pre><code>&gt; 3        --ERROR! it is expecting a statement
stdin:1: unexpected symbol near 3
&gt; return 3 -- OK!
3
&gt; = 3      -- syntax sugar in the REPL for 'return 3'
3
</code></pre>

<p>You can also run it on already written files:</p>

<pre><code>$ ./terra tests/hello.t
hello, world
</code></pre>

<p>Terra can also be used as a library from C by linking against <code>libterra.a</code>. The interface is very similar that of the <a href="http://queue.acm.org/detail.cfm?id=1983083">Lua interpreter</a>.
A simple example initializes Terra and then runs code from the file specified in each argument:</p>

<pre><code>#include &lt;stdio.h&gt;
#include "terra.h"

int main(int argc, char ** argv) {
    lua_State * L = luaL_newstate(); //create a plain lua state
    luaL_openlibs(L);                //initialize its libraries
    terra_init(L);                   //initialize the terra state in lua
    for(int i = 1; i &lt; argc; i++)
        if(terra_dofile(L,argv[i]))  //run the terra code in each file
            exit(1);
    return 0;
}
</code></pre>

<p>In addition to these modes, Terra code can be compiled to <code>.o</code> files which can be directly linked into an executable. This feature is not yet implemented. Features that are not implemented will be marked with <em>NYI</em> in this guide when they come up.</p>

<p>For the remainder of the guide, we will assume that you are using the <code>terra</code> executable to run scripts. A bunch of example scripts can be found in the <code>tests/</code> directory.</p>

<h2>Hello, World</h2>

<p>Hello world is simple:</p>

<pre><code>print("hello, world")
</code></pre>

<p>This program is actually a completely valid Lua program as well. In fact, the top-level declarations in a Terra source code file are always run as normal Lua code! This top-level Lua layer handles the details like conditional compilation, namespaces, and templating of terra code. We'll see later that it additionally allows for more powerful features such as function specialization, lisp-style macros, and code quotations.</p>

<p>To actually begin writing Terra code, we introduce a Terra function with the keyword <code>terra</code>:</p>

<pre><code>terra addone(a : int)
    return a + 1
end

print(addone(2)) --this outputs: 3
</code></pre>

<p>Unlike Lua, arguments to Terra functions are explicitly typed. Terra uses a simple static type propagation to infer the return type of the <code>addone</code> function. You can also explicitly specify it:</p>

<pre><code>terra addone(a : int) : int
</code></pre>

<p>The last line of the example invokes the Terra function from the top level context (which is Lua code). This is an example of the interaction between Terra and Lua.
Terra code is JIT compiled to machine code when it is first <em>needed</em>. In this example, this occurs when <code>addone</code> is called. In general, functions are <em>needed</em> when then are called, or when they are referred to by other functions that are being compiled. If you want to avoid the overhead of compiling code at runtime, you can also compile code ahead of time and save it in a <code>.o</code> file (NYI).</p>

<p>More information on the interface between Terra and Lua can be found in <a href="#interaction">Lua-Terra interaction</a>.</p>

<p>We can also print "hello, world" directly from Terra like so:</p>

<pre><code>local c = terralib.includec("stdio.h")

terra main()
    c.printf("hello, world\n")
end

main()
</code></pre>

<p>The function <code>terralib.includec</code> is a Lua function that invokes Terra's backward compatibility layeer to import C code in <code>stdio.h</code> into the Lua table <code>c</code>. Terra functions can then directly call the C functions. Since both clang (our C frontend) and Terra target the LLVM intermediate representation, there is no additional overhead in calling a C function. Terra can even inline across these calls if the source of the C function is available!</p>

<p>The <code>local</code> keyword is a Lua construct. It introduces a locally scoped Lua variable named <code>c</code>. If omitted it would create a globally scoped variable.</p>

<h2>Variables and Assignments</h2>

<p>Variables in Terra code are introduced with the <code>var</code> keyword:</p>

<pre><code>terra myfn()
    var a : int = 3
    var b : double
end
</code></pre>

<p>Unlike Lua, all Terra variables must be declared.  Initializers are optional. <code>b</code>'s value above is undefined until it is assigned. If an initializer is specified, then Terra can infer the variables type automatically:</p>

<pre><code>terra myfn()
    var a = 3.0 --a will have type double
end
</code></pre>

<p>You can have multiple declarations on one line:</p>

<pre><code>terra myfn()
    var a : int, b : double = 3, 4.5
    var c : double, d       = 3, 4.5
end
</code></pre>

<p>Lua and Terra are both whitespace invariant. However, there is no need for semicolons between statements. The above statement is equivalent to:</p>

<pre><code>terra myfn()
    var a : int, b : double = 3, 4.5 var c : double, d = 3, 4.5
end
</code></pre>

<p>If you want to put a semicolon in for clarity you can:</p>

<pre><code>terra myfn()
    var a : int, b : double = 3, 4.5; var c : double, d = 3, 4.5
end
</code></pre>

<p>Assignments have a similar form:</p>

<pre><code>terra myfn()
    var a,b = 3.0, 4.5
    a,b = b,a 
    -- a has value 4.5, b has value 3.0 
end
</code></pre>

<p>As in Lua, the right-hand size is executed before the assignments are performed, so the above example will swap the values of the two variables.</p>

<p>Variables can be declared outside <code>terra</code> functions as well:
    var a = 3.0
    terra myfn()
        return a
    end
This makes <code>a</code> a <em>global</em> variable that is visible to multiple Terra functions.</p>

<p>Variables in Terra are always lexically scoped. The statement <code>do &lt;stmts&gt; end</code> introduces a new level of scoping (for the remainder of this guide, the enclosing <code>terra</code> declaration will be omitted when it is clear we are talking about Terra code):</p>

<pre><code>var a = 3.0
do
    var a = 4.0
end
-- a has value 3.0 now
</code></pre>

<h2>Control Flow</h2>

<p>Terra's control flow is almost identical to Lua except for the behavior of <code>for</code> loops.</p>

<h3>If Statements</h3>

<pre><code>if a or b and not c then
    c.printf("then\n")
elseif c then
    c.printf("elseif\n")
else
    c.printf("else\n")
end
</code></pre>

<h3>Loops</h3>

<pre><code>var a = 0
while a &lt; 10 do
    c.printf("loop\n")
    a = a + 1
end

repeat
    a = a - 1
    c.printf("loop2\n")
until a == 0

while a &lt; 10 do
    if b then
        break
    end
    a = a + 1
end
</code></pre>

<p>Terra also includes <code>for</code> loop. This example counts from 0 up to but not including 10:</p>

<pre><code>for i = 0,10 do
    c.printf("%d\n",i)
end
</code></pre>

<p>This is different from Lua's behavior (which is inclusive of 10) since Terra uses 0-based indexing and pointer arithmetic in contrast with Lua's 1-based indexing. </p>

<p>Lua also has a <code>for</code> loop that operates using iterators. This is not yet implemented (NYI) in Terra, but a version will be added eventually.</p>

<p>The loop may also specify an option step parameter:</p>

<pre><code>for i = 0,10,2 do
    c.printf("%d\n",i) --0, 2, 4, ...
end
</code></pre>

<h3>Gotos</h3>

<p>Terra includes goto statements. Use them wisely. They are included since they can be useful when generating code for embedded languages.</p>

<pre><code>::loop::
c.printf("y\n")
goto loop
</code></pre>

<h2>Functions Revisited</h2>

<p>We've already seen some simple function definitions. In addition to taking multiple parameters, functions in Terra (and Lua) can return multiple values:</p>

<pre><code>terra sort2(a : int, b : int, c : int) : (int,int) --the return type is optional
    if a &lt; b then   
        return a, b
    else
        return b, a
    end
end

terra doit()
    var a,b = sort2(3,4)
    --now a == 4, b == 3
end
doit()
</code></pre>

<p>As mentioned previously, compilation occurs when functions are first <em>needed</em>. In this example, when <code>doit()</code> is called, both <code>doit()</code> and <code>sort2</code> are compiled because <code>doit</code> refers to <code>sort2</code>. </p>

<h3>Mutual Recursion</h3>

<p>Symbols such as variables and types are resolved and <em>compilation</em> time. This makes it possible to define mutually recursive functions without first declaring them:</p>

<pre><code>terra iseven(n : uint32)
    if n == 0 then
        return true
    else
        return isodd(n - 1)
    end
end

terra isodd(n : uint32)
    if n == 0 then
        return false
    else
        return iseven(n - 1)
    end
end

print(iseven(3)) -- OK! isodd has been defined
</code></pre>

<p>When <code>iseven</code> is compiled on the last line, <code>isodd</code> has been defined. </p>

<h3>Terra Functions Are Lua Objects</h3>

<p>So far, we have been treating <code>terra</code> functions as special constructs in the top-level Lua code. In reality, Terra functions are actually just Lua values. In fact, the code:</p>

<pre><code>terra foo()
end
</code></pre>

<p>Is just syntax sugar for:</p>

<pre><code>foo = terra()
    --this is an anonymous terra function
end
</code></pre>

<p>The symbol <code>foo</code> is just a Lua <em>variable</em> whose <em>value</em> is a Terra function. Lua is Terra's meta-language, and you can use it to perform reflection on Terra functions. For instance, you can ask for the function's type:</p>

<pre><code>terra add1(a : double)
    return a + 1.0
end

--this is Lua code:
&gt; print(add1:gettype())
"{double} -&gt; {double}"
</code></pre>

<p>You can also force a function to be compiled:</p>

<pre><code>add1:compile()
</code></pre>

<p>Or look at the functions internal abstract syntax tree:</p>

<pre><code>function
  parameters: 
    1: entry
         linenumber: 1
         name: a
         type: type
                 linenumber: 1
                 expression: function: 0x00065930
  linenumber: 1
  is_varargs: false
  filename: =stdin
  body: block
          linenumber: 1
          statements: 
            1: return
                 linenumber: 1
                 expressions: 
                   1: operator
                        linenumber: 1
                        operands: 
                          1: var
                               linenumber: 1
                               name: a
                          2: literal
                               value: 1
                               linenumber: 1
                               type: double
                        operator: + (enum 0)
</code></pre>

<h3>Symbol Resolution</h3>

<p>When the Terra compiler looks up a symbol like <code>add1</code> it first looks in the local environment of the <code>terra</code> function. If it doesn't find the symbol, then it simply continues the search in the enclosing (Lua) environment. If the compiler resolves the symbol to a Lua value, then it converts it to a Terra value where possible. Let's look at a few examples:</p>

<pre><code>local N = 4
terra powN(a : double)
    var r = 1
    for i = 0, N do
        r = r * a
    end
    return r
end
</code></pre>

<p>Here <code>N</code> is a Lua value of type <code>number</code>. When <code>powN</code> is compiled, the value of <code>N</code> is looked up and inlined into the function. </p>

<p>Since <code>N</code> is resolved at <em>compile</em> time, changing <code>N</code> after <code>powN</code> is compiled will not change the behavior of <code>powN</code>.  For this reason, it is strongly recommended that you don't change the value of Lua variables that appear in Terra code once they are initialized.</p>

<p>Of course, a single power function is boring. Instead we might want to create specialized versions of 10 power functions:</p>

<pre><code>local math = {}
for i = 1,10 do
    math["pow"..tostring(i)] = terra(a : double)
        var r = 1
        for i = 0, i do
            r = r * a
        end
        return r
    end
end

math.pow1(2) -- 2
math.pow2(2) -- 4
math.pow3(2) -- 8
</code></pre>

<p>Here we use the fact that in Lua the select operator on tables (<code>a.b</code>) is equivalent to looking up the value in table (<code>a["b"]</code>).</p>

<p>You can also call these power functions from a Terra function:</p>

<pre><code>terra doit()
    return math.pow3(3) 
end
</code></pre>

<p>Let's examine what is happens when this function is compiled. The Terra compiler will resolve the <code>math</code> symbol to the Lua table holding the power functions. It will then see the select operator (<code>math.pow3</code>). Because <code>math</code> is a Lua table, the Terra compiler will perform this select operator at compile time, and resolve <code>math.pow3</code> to the third Terra function constructed inside the loop.  It will then insert a direct call to that function inside <code>doit</code>. This behavior is a form of <em>partial execution</em>. In general, Lua will resolve any chain of select operations <code>a.b.c.d</code> at compile time. This behavior enables Terra to use Lua tables to organize code into different namespaces. There is no need for a Terra specific namespace mechanism!</p>

<p>Recall how we can include C files:</p>

<pre><code>local c = terralib.includec("stdio.h")
</code></pre>

<p><code>terralib.includec</code> is just a normal Lua function. It builds a Lua table that contains references to the Terra functions that represent calls to (in this case) the standard library functions. We can iterate through the table as well:</p>

<pre><code>for k,v in pairs(c) do
    print(k)
end
--output:
fseek
gets
printf
puts
FILE
...
</code></pre>

<h3>Scoping</h3>

<p>Additionally, you may want to declare a Terra function as a <em>locally</em> scoped Lua variable. You can use the <code>local</code> keyword:</p>

<pre><code>local terra foo()
end
</code></pre>

<p>Which is just sugar for:</p>

<pre><code>local foo; foo = terra()
end()
</code></pre>

<h2>Types and Operators</h2>

<p>Terra's type system closely resembles the type system of C, with a few differences that make it interoperate better with the Lua language.</p>

<h3>Primitive Types</h3>

<p>We've already seen some basic Terra types like <code>int</code> or <code>double</code>. Terra has the usual set of basic types:</p>

<ul>
<li>Integers: <code>int</code> <code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code></li>
<li>Unsigned integers: <code>uint</code> <code>uint8</code> <code>uint16</code> <code>uint32</code> <code>uint64</code></li>
<li>Boolean: <code>bool</code></li>
<li>Floating Point: <code>float</code> <code>double</code></li>
</ul>

<p>Integers are explicitly sized except for <code>int</code> and <code>uint</code> which should only be used when the particular size is not important. Most implicit conversions from C are also valid in Terra. The one major exception is the <code>bool</code> type. Unlike C, all control-flow explicitly requires a <code>bool</code> and integers are not explicitly convertible to <code>bool</code>.</p>

<pre><code>if 3 then end -- ERROR 3 is not bool
if 3 == 0 then end -- OK! 3 == 0 is bool
</code></pre>

<p>You can force the conversion from <code>int</code> to <code>bool</code> using an explicit cast:</p>

<pre><code>var a : bool = (3):as(bool)
</code></pre>

<p>The <code>a:b(c)</code> syntax is a method invocation syntax borrowed from Lua that will be discussed later.</p>

<p>Primitive types have the standard operators defined:</p>

<ul>
<li>Arithmetic: <code>- + * / %</code></li>
<li>Comparison: <code>&lt; &lt;= &gt; &gt;= == ~=</code></li>
<li>Logical: <code>and or not</code></li>
<li>Bitwise: <code>and or not ^ &lt;&lt; &gt;&gt;</code></li>
</ul>

<p>These behave the same C except for the logical operators, which are overloaded based on the type of the operators:</p>

<pre><code>true and false --Lazily evaluated logical and
1 and 3        --Eagerly evaluated bitwise and
</code></pre>

<h3>Pointers</h3>

<p>Pointers behave similarly to C, including pointer arithmetic. The syntax is slightly different to work with Lua's grammar:</p>

<pre><code>var a : int = 1
var pa : &amp;int = &amp;a
@a = 4
var b = @a
</code></pre>

<p>You can read <code>&amp;int</code> as a value holding the <em>address</em> of an <code>int</code>, and <code>@a</code> as the value <em>at</em> address <code>a</code>. To get a pointer to allocated memory you can use <code>malloc</code>:</p>

<pre><code>c = terralib.includec("stdlib.h")
terra doit()
    var a = c.malloc(sizeof(int) * 3):as(&amp;int)
    @a,@(a+1) = 1,2
end
</code></pre>

<p>Indexing operators also work on pointers:</p>

<pre><code>a[3] --syntax sugar for @(a + 3)
</code></pre>

<h3>Arrays</h3>

<p>You can construct statically sized arrays as well:</p>

<pre><code>var a : int[4]
a[0],a[1],a[2],a[3] = 0,1,2,3
</code></pre>

<p>In constrast to Lua, Terra uses 0-based indexing since everything is based on offsets. <code>&amp;int[3]</code> is a pointer to an array of length 3. <code>(&amp;int)[3]</code> is an array of three pointers to integers.</p>

<h3>Vectors (NYI)</h3>

<p>Vectors are like arrays, but also allow you to perform vector-wide operations:</p>

<pre><code>terra diffuse(L : vec(float,3), V : vec(float,3), N : vec(float,3))
    var H = (L + V) / size(L + V)
    return dot(H,N)
end
</code></pre>

<p>They serve as an abstraction of the SIMD instructions (like Intel's SSE or Arm's NEON ISAs), allowing you to write vectorized code.</p>

<h3>Structs</h3>

<p>You can create aggregate types using the <code>struct</code> keyword. Structs must be declared outside of Terra code:</p>

<pre><code>struct Complex { real : float; imag : float; }
terra doit()
    var c : Complex
    c.real = 4
    c.imag = 5
end
</code></pre>

<p>Like functions, symbols in struct definitions are resolved at compile time, allowing for recursive structural types:</p>

<pre><code>struct LinkedList { value : int; next : &amp;LinkedList; }
</code></pre>

<p>Terra has no union type. Instead, you can declare that you want two or more elements of the struct to share the same memory:</p>

<pre><code>struct MyStruct { 
    a : int; --unique memory
    union { 
        b : double;  --memory for b and c overlap
        c : int;
    } 
}
</code></pre>

<h3>Anonymous Structs</h3>

<p>In Terra you can also create structs that have no name:
    var a : struct { real : float, imag : float } </p>
