Language Implementation:


-- how to save results for later (both Lua state and Terra JIT state)
-- generate TBAA metadata like C will so that we can match perf (do we need?)
-- gather and scatter for vectors (allow vec(int*) and its loads)
-- pointer arithmetic on niltype?
-- returning values from lua functions   
-- better handling of options to try for overloaded operators
-- better handling of lua layout of structs with recursion (can we seperate the creation of structs for their layout to simplify the problem) -- test the compiler fo handling jitting of functions previously optimized with nojit = true
   (look into the way LLVM handles pointers to opaque structs, can we delay layout of a struct until we need to access it similar to the way C allows opaque struct pointers).
-- tests for garbage collection of objects that mix LLVM state with Lua state to check for memory leaks from dangling references
-- better interaction for low-level values allocated from Lua and used in Terra.
--track down why some types RecordType structs do not have names, and fix the bugs that are caused by this. 
--&&type should convert to &&uint8 (check number of addresses is the same, currently only allows &foo to convert to &uint8)
--look into bug: if you cast an lvalue pointer to another pointer, it becomes an rvalue, this is not right...

DONE:
--function pointers
--anonymous structural type cast to other structural types
--methods on types (declaration syntax )
--methods on types (call syntax/resolution) 
-- -> and & syntax need to work in normal lua code (not just type resolution)
-- types should be presented in the AST as the string of lua code to run to get the type rather than an AST needed to be interpreted--eval types:
   change types to have either canonical versions or exist as proxy objects
   type constructors (e.g. pointer to) should ask if a type is canonical and create a proxy if not)
--pointer arithmetic
--array types
--resolvetype needs to allow the declaration of anonymous structural types
--macros in terra
-- explicit casts (pointer to pointer, requires macros to somewhat work)
-- constructor syntax with a function in last position should create 1 anonymous entry per return value of the function
-- string literals translated to int8* types
-- how to use clang to read C header files
-- an opaque type (equivalent to void* in C) (? another alternative is to just use int8* for  now) (went with: no unsized opaque types, but some imported c types do now expose internals)
-- support typedefs and record types in C header files
-- automatic conversion from any pointer to &uint8
-- nil should translate to any pointer type's NULL value, this will require adding an implicit conversion for <nulltype> to any pointer type,
   and allowing nulltype to exist
-- union annontations in struct types
-- support for aggregate types in Lua-terra interface
   extend cstring to work for arrays and structs (+unions) being careful to work for recursive types
   to work around c's weird syntax, each non-primitive will need to generate a typedef for its type
   fold the typedef for functions into cstring and simplify makewrapper to use its type instead
   pointers to functions will need to be handled as a special case
--calling lua functions from terra
-- turn debug on/off debug printing
-- introduce LL, ULL, and f to make constants have the expected types
-- simple save of functions (give a key-value pair and export the symbols with those names to a .o file, see if you can use aliases to export these functions)
-- code quotations of statements and expressions
-- getting started guide
-- revise how quoted code is injected into AST. In particular, macros should not drop Quote objects into the AST (it should instead resolve the quotes in place)
   also consider the way that checkexp allows quote objects to propogate: consider a different design where untyped code is first resolved:
      vars are check if they are Quotes and inserted as Quote nodes
      same goes for global variables
      partial eval of select is handeld
      macro nodes are expanded (recursively) until there are no non-tree literals left
-- good error message for when there is a circular dependency on global variable initializationlocation like old C for now)
-- getting the right -O3 passes (llvm-as < /dev/null | opt -O3 -disable-output -debug-pass=Arguments)
   handle as much as possible in the JIT, and make sure the offline compiler does everything
   make configurable (perhaps a general config mechanism) (look a preconfigured stuff)
-- write 1 or two language benchmarks in terra to get baseline perf (do this after figuring out -O3)
-- creating references to variables found in another quote object despite hygiene
-- vector types
-- overloaded functions
-- overloaded operator behavior
-- fix gc issues cleaning up functions: 1. either resolve symbols for quotes and functions once and throw away the env, or 2. trace references to local variables in the parser and construct the environment so that it only captures the referenced variables (this is probably the better solution, but changing the parser to do it may be tricky).
